input {
    file {
        path => "/tmp/WoWCombatLog.txt"
        type => "wowcombatlog"
        start_position => "beginning"
    }
}

filter {
    grok {
	   match => {"message" => "%{MONTHNUM}/%{MONTHDAY}%{SPACE}%{TIME:time}%{SPACE}%{GREEDYDATA:rawevent}" }
    }
    date {
	   match => ["timestamp", "MM/dd HH:mm:ss.SSS"]
       target => "@timestamp"
    }
    ruby{
        code => 'eventSplit = [event.get("rawevent").split(",")].inject([]) {|r, v| [v[0..8].join(","), v[9..-1].join(",")]}
        event.set("pdata",eventSplit[0])
        event.set("sdata",eventSplit[1])'
    }
    csv {
    
    columns => ["event", "sourceGUID", "SourceName", "sourceFlags", "sourceRaidFlags", "destGUID", "destName", "destFlags", "destRaidFlags"]
    source => "pdata"
    remove_field => "pdata"
    }
     # First we need to look at the starting of the event to determine the next set of fields to pull
    if [event] =~ /^RANGE/  or [event] =~ /^SPELL/ or [event] =~ /^DAMAGE"/ {
    ruby {
        code => 'eventSplit = [event.get("sdata").split(",")].inject([]) {|r, v| [v[0..2].join(","), v[3..-1].join(",")]}
                event.set("prdata", eventSplit[0])
                event.set("sudata", eventSplit[1])'
    }
    mutate {
        remove_field => "sdata"
    }
        csv {
        columns => ["spellId", "SpellName", "SpellSchool"]
        source => "prdata"
        remove_field => "prdata"
    }
    } else {
    # We don't have any prefix data, so we need to move prdata into sudata for suffix data
    mutate {
        rename => ['sdata', 'sudata']
    }
    } 
    # Some events have a bunch of extra data we need to parse, lets pull them out
    if [event] =~ /_DAMAGE$/ or [event] =~ /_DAMAGE_LANDED$/ or [event] =~ /_HEAL$/ or [event] =~ /_ENERGIZE$/ {
    ruby {
        code => 'eventSplit = [event.get("sudata").split(",")].inject([]) {|r, v| [v[0..11].join(","), v[12..-1].join(",")]}
                event.set("xdata", eventSplit[0])
                event.set("sudata", eventSplit[1])'
    }
        csv {
        columns => ["guid", "unknown0", "currenthealth", "maxhealth", "attackpower", "spellpower", "unknown1", "powertype", "currentpower", "maxpower", "xLoc", "yLoc", "itemlevel"]
        source => "xdata"
        remove_field => "xdata"
        
    }
    }
    # Enviromental event has it's prefix data after the xdata above. 
    if [event] =~ /^ENVIRONMENTAL/ {
    ruby {
        code => 'eventSplit = [event.get("sudata").split(",")].inject([]) {|r, v| [v[0..0].join(","), v[1..-1].join(",")]}
                event.set("prdata", eventSplit[0])
                event.set("sudata", eventSplit[1])'
    }
        csv {
        columns => ["environmentalType"]
        source => "prdata"
        remove_field => "prdata"
        
    }
    }
    # Next, we look at the ending of the event to gather the last fields
    # We'll put the most used at the top
    if [event] =~ /_DAMAGE$/ or [event] =~ /_DAMAGE_LANDED$/ {
        csv {
        columns => ["amount", "overkill", "school", "resisted", "blocked", "absorbed", "critical", "glancing", "crushing", "isOffHand"]
        source => "sudata"
        remove_field => "sudata"
        
    }
    } else if [event] =~ /_MISSED$/ {
        csv {
        columns => ["missType", "isOffHand", "amountMissed"]
        source => "sudata"
        remove_field => "sudata"
        
    }
    } else if [event] =~ /_HEAL$/ {
        csv {
        columns => ["amount", "overhealing", "absorbed", "critical"]
        source => "sudata"
        remove_field => "sudata"
        
    }
    }else if [event] =~ /_ENERGIZE$/ { 
        csv {
        columns => ["amount", "powerType", "extraAmount","alternatePowerType"]
        source => "sudata"
        remove_field => "sudata"
        
    }    
    } else if [event] =~ /_LEECH$/ or [event] =~ /_DRAIN$/ { 
        csv {
        columns => ["amount", "powerType", "extraAmount"]
        source => "sudata"
        remove_field => "sudata"
        
    }
    } else if [event] =~ /_INTERRUPT$/ or [event] =~ /_DISPEL_FAILED$/ {
        csv {
        columns => ["extraSpellId", "extraSpellName", "extraSchool"]
        source => "sudata"
        remove_field => "sudata"
        
    }
    } else if [event] =~ /_DISPEL$/ or [event] =~ /_STOLEN$/ {
        csv {
        columns => ["extraSpellId", "extraSpellName", "extraSchool", "auraType"]
        source => "sudata"
        remove_field => "sudata"        
    }
    } else if [event] =~ /_EXTRA_ATTACKS$/ {
        csv {
        columns => ["amount"]
        source => "sudata"
        remove_field => "sudata"
        
    }   
    }else if [event] =~ /_AURA_REFRESH$/ or [event] =~ /_AURA_REMOVED_DOSE$/ or [event] =~ /_AURA_APPLIED_DOSE$/ or [event] =~ /_AURA_REMOVED$/ or [event] =~ /_AURA_APPLIED$/ {
        csv {
        columns => ["auraType", "amount"]
        source => "sudata"
        remove_field => "sudata"
    }  
    }else if [event] =~ /_AURA_BROKEN$/ {
        csv {
        columns => ["auraType"]
        source => "sudata"
        remove_field => "sudata"
    }        
    }else if [event] =~ /_AUORA_BROKEN_SPELL$/ {
        csv {
        columns => ["extraSpellId", "extraSpellName", "extraSchool", "auraType"]
        source => "sudata"
        remove_field => "sudata"
    }    
    } else if [event] =~ /_CAST_FAILED$/ {
        csv {
        columns => ["failedType"]
        source => "sudata"
        remove_field => "sudata"
        
    }
    }

}


output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    user => elastic
	password => changeme
    index => combatlog
  }
  stdout { codec => rubydebug }
}